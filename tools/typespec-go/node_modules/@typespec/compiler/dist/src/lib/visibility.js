// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { validateDecoratorTarget, validateDecoratorUniqueOnNode } from "../core/decorator-utils.js";
import { reportDiagnostic } from "../core/messages.js";
import { addVisibilityModifiers, clearLegacyVisibility, clearVisibilityModifiersForClass, getLegacyVisibility, getVisibility, isVisible, removeVisibilityModifiers, resetVisibilityModifiersForClass, setDefaultModifierSetForVisibilityClass, setLegacyVisibility, VisibilityFilter, } from "../core/visibility/core.js";
import { getLifecycleVisibilityEnum, normalizeVisibilityToLegacyLifecycleString, } from "../core/visibility/lifecycle.js";
import { isMutableType, mutateSubgraph, MutatorFlow } from "../experimental/mutators.js";
import { isKey } from "./key.js";
import { filterModelPropertiesInPlace, useStateMap } from "./utils.js";
// #region Legacy Visibility Utilities
/**
 * Takes a list of visibilities that possibly include both legacy visibility
 * strings and visibility class members, and returns two lists containing only
 * each type.
 *
 * @param visibilities - The list of visibilities to split
 * @returns a tuple containing visibility enum members in the first position and
 *         legacy visibility strings in the second position
 */
function splitLegacyVisibility(visibilities) {
    const legacyVisibilities = [];
    const modifiers = [];
    for (const visibility of visibilities) {
        if (typeof visibility === "string") {
            legacyVisibilities.push(visibility);
        }
        else {
            modifiers.push(visibility.value);
        }
    }
    return [modifiers, legacyVisibilities];
}
export const $withDefaultKeyVisibility = (context, entity, visibility) => {
    const keyProperties = [];
    entity.properties.forEach((prop) => {
        // Keep track of any key property without a visibility
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        if (isKey(context.program, prop) && !getVisibility(context.program, prop)) {
            keyProperties.push(prop);
        }
    });
    // For each key property without a visibility, clone it and add the specified
    // default visibility value
    keyProperties.forEach((keyProp) => {
        entity.properties.set(keyProp.name, context.program.checker.cloneType(keyProp, {
            decorators: [
                ...keyProp.decorators,
                {
                    decorator: $visibility,
                    args: [
                        {
                            value: typeof visibility === "string"
                                ? context.program.checker.createLiteralType(visibility)
                                : visibility,
                            jsValue: visibility,
                        },
                    ],
                },
            ],
        }));
    });
};
const [getOperationVisibilityConfigRaw, setOperationVisibilityConfigRaw] = useStateMap("operationVisibilityConfig");
function getOperationVisibilityConfig(program, operation) {
    let config = getOperationVisibilityConfigRaw(program, operation);
    if (!config) {
        config = {};
        setOperationVisibilityConfigRaw(program, operation, config);
    }
    return config;
}
export const $parameterVisibility = (context, operation, ...visibilities) => {
    validateDecoratorUniqueOnNode(context, operation, $parameterVisibility);
    const [modifiers, legacyVisibilities] = splitLegacyVisibility(visibilities);
    if (modifiers.length > 0 && legacyVisibilities.length > 0) {
        reportDiagnostic(context.program, {
            code: "visibility-mixed-legacy",
            target: context.decoratorTarget,
        });
        return;
    }
    if (modifiers.length > 0) {
        getOperationVisibilityConfig(context.program, operation).parameters = modifiers;
    }
    else {
        getOperationVisibilityConfig(context.program, operation).parameters = legacyVisibilities;
    }
};
/**
 * Returns the visibilities of the parameters of the given operation, if provided with `@parameterVisibility`.
 *
 * @see {@link $parameterVisibility}
 */
export function getParameterVisibility(program, entity) {
    return getOperationVisibilityConfig(program, entity)
        .parameters?.map((p) => typeof p === "string" ? p : normalizeVisibilityToLegacyLifecycleString(program, p))
        .filter((p) => !!p);
}
export const $returnTypeVisibility = (context, operation, ...visibilities) => {
    validateDecoratorUniqueOnNode(context, operation, $parameterVisibility);
    const [modifiers, legacyVisibilities] = splitLegacyVisibility(visibilities);
    if (modifiers.length > 0 && legacyVisibilities.length > 0) {
        reportDiagnostic(context.program, {
            code: "visibility-mixed-legacy",
            target: context.decoratorTarget,
        });
        return;
    }
    if (modifiers.length > 0) {
        getOperationVisibilityConfig(context.program, operation).returnType = modifiers;
    }
    else {
        getOperationVisibilityConfig(context.program, operation).returnType = legacyVisibilities;
    }
};
/**
 * Returns the visibilities of the return type of the given operation, if provided with `@returnTypeVisibility`.
 *
 * @see {@link $returnTypeVisibility}
 */
export function getReturnTypeVisibility(program, entity) {
    return getOperationVisibilityConfig(program, entity)
        .returnType?.map((p) => typeof p === "string" ? p : normalizeVisibilityToLegacyLifecycleString(program, p))
        .filter((p) => !!p);
}
// #endregion
// #region Core Visibility Decorators
// -- @visibility decorator ---------------------
export const $visibility = (context, target, ...visibilities) => {
    const [modifiers, legacyVisibilities] = splitLegacyVisibility(visibilities);
    if (legacyVisibilities.length > 0 || visibilities.length === 0) {
        const isUnique = validateDecoratorUniqueOnNode(context, target, $visibility);
        if (modifiers.length > 0) {
            reportDiagnostic(context.program, {
                code: "visibility-mixed-legacy",
                target: context.decoratorTarget,
            });
            return;
        }
        // Only attempt to set the legacy visibility modifiers if the visibility invocation is unique. Otherwise, a compiler
        // assertion will fail inside the legacy visibility management API.
        if (isUnique)
            setLegacyVisibility(context, target, legacyVisibilities);
    }
    else {
        if (getLegacyVisibility(context.program, target)) {
            reportDiagnostic(context.program, {
                code: "visibility-mixed-legacy",
                target: context.decoratorTarget,
            });
        }
        addVisibilityModifiers(context.program, target, modifiers, context);
    }
};
// -- @removeVisibility decorator ---------------------
export const $removeVisibility = (context, target, ...visibilities) => {
    removeVisibilityModifiers(context.program, target, visibilities.map((v) => v.value));
};
// -- @invisible decorator ---------------------
export const $invisible = (context, target, visibilityClass) => {
    clearVisibilityModifiersForClass(context.program, target, visibilityClass);
};
// -- @defaultVisibility decorator ------------------
export const $defaultVisibility = (context, target, ...visibilities) => {
    validateDecoratorUniqueOnNode(context, target, $defaultVisibility);
    const modifierSet = new Set();
    for (const visibility of visibilities) {
        if (visibility.value.enum !== target) {
            reportDiagnostic(context.program, {
                code: "default-visibility-not-member",
                target: context.decoratorTarget,
            });
        }
        else {
            modifierSet.add(visibility.value);
        }
    }
    setDefaultModifierSetForVisibilityClass(context.program, target, modifierSet);
};
// #endregion
// #region Legacy Visibility Transforms
// -- @withVisibility decorator ---------------------
export const $withVisibility = (context, target, ...visibilities) => {
    const [modifiers, legacyVisibilities] = splitLegacyVisibility(visibilities);
    if (legacyVisibilities.length > 0) {
        if (modifiers.length > 0) {
            reportDiagnostic(context.program, {
                code: "visibility-mixed-legacy",
                target: context.decoratorTarget,
            });
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        filterModelPropertiesInPlace(target, (p) => isVisible(context.program, p, legacyVisibilities));
        for (const p of target.properties.values()) {
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            const legacyModifiers = getVisibility(context.program, p);
            if (legacyModifiers && legacyModifiers.length > 0) {
                clearLegacyVisibility(context.program, p);
            }
            else {
                resetVisibilityModifiersForClass(context.program, p, getLifecycleVisibilityEnum(context.program));
            }
        }
    }
    else {
        const filter = {
            all: new Set(modifiers),
        };
        const visibilityClasses = new Set(modifiers.map((m) => m.enum));
        filterModelPropertiesInPlace(target, (p) => isVisible(context.program, p, filter));
        for (const p of target.properties.values()) {
            for (const c of visibilityClasses) {
                resetVisibilityModifiersForClass(context.program, p, c);
            }
        }
    }
};
// -- @withUpdateableProperties decorator ----------------------
/**
 * Filters a model for properties that are updateable.
 *
 * @param context - the program context
 * @param target - Model to filter for updateable properties
 */
export const $withUpdateableProperties = (context, target) => {
    if (!validateDecoratorTarget(context, target, "@withUpdateableProperties", "Model")) {
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    filterModelPropertiesInPlace(target, (p) => isVisible(context.program, p, ["update"]));
};
// #endregion
// #region Mutator Driven Transforms
// -- @withVisibilityFilter decorator ----------------------
export const $withVisibilityFilter = (context, target, _filter) => {
    const filter = VisibilityFilter.fromDecoratorArgument(_filter);
    const vfMutator = createVisibilityFilterMutator(filter, {
        decoratorFn: $withVisibilityFilter,
    });
    const { type } = mutateSubgraph(context.program, [vfMutator], target);
    target.properties = type.properties;
};
// -- @withLifecycleUpdate decorator ----------------------
export const $withLifecycleUpdate = (context, target) => {
    const lifecycle = getLifecycleVisibilityEnum(context.program);
    const lifecycleUpdate = {
        all: new Set([lifecycle.members.get("Update")]),
    };
    const lifecycleCreateOrUpdate = {
        any: new Set([lifecycle.members.get("Create"), lifecycle.members.get("Update")]),
    };
    const createOrUpdateMutator = createVisibilityFilterMutator(lifecycleCreateOrUpdate);
    const updateMutator = createVisibilityFilterMutator(lifecycleUpdate, {
        recur: createOrUpdateMutator,
        decoratorFn: $withLifecycleUpdate,
    });
    const { type } = mutateSubgraph(context.program, [updateMutator], target);
    target.properties = type.properties;
};
/**
 * Create a mutator that applies a visibility filter to a type.
 *
 * @param filter - The visibility filter to apply
 * @param options - optional settings for the mutator
 * @returns
 */
function createVisibilityFilterMutator(filter, options = {}) {
    const visibilityClasses = VisibilityFilter.getVisibilityClasses(filter);
    const mpMutator = {
        name: "VisibilityFilterProperty",
        ModelProperty: {
            filter: () => MutatorFlow.DoNotRecur,
            mutate: (prop, clone, program) => {
                // We need to create a copy of the decorators array to avoid modifying the original.
                // Decorators are _NOT_ cloned by the type kit, so we have to be careful not to modify the decorator arguments
                // of the original type.
                const decorators = [];
                for (const decorator of prop.decorators) {
                    const decFn = decorator.decorator;
                    if (decFn === $visibility || decFn === $removeVisibility) {
                        const nextArgs = decorator.args.filter((arg) => {
                            if (arg.value.entityKind !== "Value")
                                return false;
                            const isString = arg.value.valueKind === "StringValue";
                            const isOperativeVisibility = arg.value.valueKind === "EnumValue" && visibilityClasses.has(arg.value.value.enum);
                            return !(isString || isOperativeVisibility);
                        });
                        if (nextArgs.length > 0) {
                            decorators.push({
                                ...decorator,
                                args: nextArgs,
                            });
                        }
                    }
                    else if (decFn !== $invisible) {
                        decorators.push(decorator);
                    }
                }
                clone.decorators = decorators;
                for (const visibilityClass of visibilityClasses) {
                    resetVisibilityModifiersForClass(program, clone, visibilityClass);
                }
                if (isMutableType(prop.type)) {
                    clone.type = mutateSubgraph(program, [options.recur ?? self], prop.type).type;
                }
            },
        },
    };
    const self = {
        name: "VisibilityFilter",
        Union: {
            filter: () => MutatorFlow.DoNotRecur,
            mutate: (union, clone, program) => {
                for (const [key, member] of union.variants) {
                    if (member.type.kind === "Model" || member.type.kind === "Union") {
                        const variant = {
                            ...member,
                            type: mutateSubgraph(program, [self], member.type).type,
                        };
                        clone.variants.set(key, variant);
                    }
                }
            },
        },
        Model: {
            filter: () => MutatorFlow.DoNotRecur,
            mutate: (model, clone, program, realm) => {
                for (const [key, prop] of model.properties) {
                    if (!isVisible(program, prop, filter)) {
                        // Property is not visible, remove it
                        clone.properties.delete(key);
                        realm.remove(clone);
                    }
                    else {
                        const mutated = mutateSubgraph(program, [mpMutator], prop);
                        clone.properties.set(key, mutated.type);
                    }
                }
                if (options.decoratorFn) {
                    clone.decorators = clone.decorators.filter((d) => d.decorator !== options.decoratorFn);
                }
            },
        },
        ModelProperty: {
            filter: () => MutatorFlow.DoNotRecur,
            mutate: (prop, clone, program) => {
                if (isMutableType(prop.type)) {
                    clone.type = mutateSubgraph(program, [self], prop.type).type;
                }
            },
        },
        Tuple: {
            filter: () => MutatorFlow.DoNotRecur,
            mutate: (tuple, clone, program) => {
                for (const [index, element] of tuple.values.entries()) {
                    if (isMutableType(element)) {
                        clone.values[index] = mutateSubgraph(program, [self], element).type;
                    }
                }
            },
        },
    };
    return self;
}
// #endregion
//# sourceMappingURL=visibility.js.map