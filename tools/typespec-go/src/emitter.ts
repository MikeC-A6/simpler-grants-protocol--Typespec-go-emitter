import { Program, Type, Model, getTypeName, navigateProgram } from "@typespec/compiler";
import { getGoType } from "./go-types.js";
import { collectInterfaces, GoInterface, GoOperation } from "./interfaces.js";
import { join } from "path";

export interface EmitterOptions {
  packageName?: string;
  outputDir?: string;
}

export class GoEmitter {
  private program: Program | Record<string, Type>;
  private options: Required<EmitterOptions>;
  private imports: Set<string>;

  constructor(program: Program | Record<string, Type>, options: EmitterOptions = {}) {
    this.program = program;
    this.options = {
      packageName: options.packageName || "api",
      outputDir: options.outputDir || "generated",
    };
    this.imports = new Set<string>();
  }

  generateModelCode(model: Model): string {
    const modelName = getTypeName(model);
    let code = `// ${modelName} represents a generated model\n`;
    code += `type ${modelName} struct {\n`;

    // Generate struct fields
    for (const [propName, prop] of model.properties) {
      const goType = getGoType(this.program as Program, prop.type);
      if (goType.imports) {
        goType.imports.forEach((imp) => this.imports.add(imp));
      }

      const fieldType = goType.isPointer ? `*${goType.name}` : goType.name;
      code += `\t${propName} ${fieldType} \`json:"${propName}${prop.optional ? ",omitempty" : ""}"\`\n`;
    }

    code += "}\n\n";
    return code;
  }

  generateInterfaceCode(iface: GoInterface): string {
    let code = "";
    
    // Add documentation if available
    if (iface.documentation) {
      code += `// ${iface.documentation}\n`;
    }
    
    code += `type ${iface.name} interface {\n`;
    
    // Generate methods for each operation
    for (const op of iface.operations) {
      code += this.generateOperationSignature(op);
    }
    
    code += "}\n\n";
    return code;
  }

  generateOperationSignature(op: GoOperation): string {
    let code = "";
    
    // Add documentation if available
    if (op.documentation) {
      code += `\t// ${op.documentation}\n`;
    }
    
    // Start method signature
    code += `\t${op.name}(ctx context.Context`;
    
    // Add parameters
    for (const param of op.parameters) {
      const paramType = param.isPointer ? `*${param.type}` : param.type;
      code += `, ${param.name} ${paramType}`;
    }
    
    // Add return types
    code += `) (${op.returnType}, error)\n`;
    
    return code;
  }

  generateFileHeader(): string {
    // Add context to imports
    this.imports.add("context");

    let header = `// Code generated by @common-grants/typespec-go. DO NOT EDIT.\n\n`;
    header += `package ${this.options.packageName}\n\n`;

    if (this.imports.size > 0) {
      header += "import (\n";
      this.imports.forEach((imp) => {
        header += `\t"${imp}"\n`;
      });
      header += ")\n\n";
    }

    return header;
  }

  async emit(): Promise<Map<string, string>> {
    const files = new Map<string, string>();
    const models = new Set<Model>();

    // Collect all models from the program
    navigateProgram(this.program as Program, {
      model: (model) => {
        // Skip built-in models and those from other libraries
        if (!model.name.startsWith("TypeSpec.") && !model.name.includes("@typespec")) {
          models.add(model);
        }
      },
    });

    // Generate models.go
    if (models.size > 0) {
      let modelsContent = "";
      
      // Generate code for each model
      for (const model of models) {
        modelsContent += this.generateModelCode(model);
      }

      // Create the complete file content with header
      const fullContent = this.generateFileHeader() + modelsContent;
      
      // Store the generated file
      const outputPath = join(this.options.outputDir, "models.go");
      files.set(outputPath, fullContent);
    }

    // Generate api.go for interfaces
    const interfaces = collectInterfaces(this.program as Program);
    if (interfaces.length > 0) {
      let apiContent = "";
      
      // Generate code for each interface
      for (const iface of interfaces) {
        apiContent += this.generateInterfaceCode(iface);
      }

      // Create the complete file content with header
      const fullContent = this.generateFileHeader() + apiContent;
      
      // Store the generated file
      const outputPath = join(this.options.outputDir, "api.go");
      files.set(outputPath, fullContent);
    }

    return files;
  }
} 